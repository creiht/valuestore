package store

import (
    "encoding/binary"
    "fmt"
    "io"
    "path"
    "sync"
    "sync/atomic"
    "time"

    "github.com/spaolacci/murmur3"
    "gopkg.in/gholt/brimutil.v1"
)

type {{.t}}StoreFile struct {
    store                       *Default{{.T}}Store
    name                        string
    id                          uint32
    nameTimestamp               int64
    readerFPs                   []brimutil.ChecksummedReader
    readerLocks                 []sync.Mutex
    readerLens                  [][]byte
    writerFP                    io.WriteCloser
    writerOffset                uint32
    writerFreeBufChan           chan *{{.t}}StoreFileWriteBuf
    writerChecksumBufChan       chan *{{.t}}StoreFileWriteBuf
    writerToDiskBufChan         chan *{{.t}}StoreFileWriteBuf
    writerDoneChan              chan struct{}
    writerCurrentBuf            *{{.t}}StoreFileWriteBuf
    freeableMemBlockChanIndex   int
}

type {{.t}}StoreFileWriteBuf struct {
    seq         int
    buf         []byte
    offset      uint32
    memBlocks   []*{{.t}}MemBlock
}

func new{{.T}}ReadFile(store *Default{{.T}}Store, nameTimestamp int64, openReadSeeker func(name string) (io.ReadSeeker, error)) (*{{.t}}StoreFile, error) {
    fl := &{{.t}}StoreFile{store: store, nameTimestamp: nameTimestamp}
    fl.name = path.Join(store.path, fmt.Sprintf("%019d.{{.t}}", fl.nameTimestamp))
    fl.readerFPs = make([]brimutil.ChecksummedReader, store.fileReaders)
    fl.readerLocks = make([]sync.Mutex, len(fl.readerFPs))
    fl.readerLens = make([][]byte, len(fl.readerFPs))
    for i := 0; i < len(fl.readerFPs); i++ {
        fp, err := openReadSeeker(fl.name)
        if err != nil {
            return nil, err
        }
        fl.readerFPs[i] = brimutil.NewChecksummedReader(fp, int(store.checksumInterval), murmur3.New32)
        fl.readerLens[i] = make([]byte, 4)
    }
    var err error
    fl.id, err = store.addLocBlock(fl)
    if err != nil {
        fl.close()
        return nil, err
    }
    return fl, nil
}

func create{{.T}}ReadWriteFile(store *Default{{.T}}Store, createWriteCloser func(name string) (io.WriteCloser, error), openReadSeeker func(name string) (io.ReadSeeker, error)) (*{{.t}}StoreFile, error) {
    fl := &{{.t}}StoreFile{store: store, nameTimestamp: time.Now().UnixNano()}
    fl.name = path.Join(store.path, fmt.Sprintf("%019d.{{.t}}", fl.nameTimestamp))
    fp, err := createWriteCloser(fl.name)
    if err != nil {
        return nil, err
    }
    fl.writerFP = fp
    fl.writerFreeBufChan = make(chan *{{.t}}StoreFileWriteBuf, store.workers)
    for i := 0; i < store.workers; i++ {
        fl.writerFreeBufChan <- &{{.t}}StoreFileWriteBuf{buf: make([]byte, store.checksumInterval+4)}
    }
    fl.writerChecksumBufChan = make(chan *{{.t}}StoreFileWriteBuf, store.workers)
    fl.writerToDiskBufChan = make(chan *{{.t}}StoreFileWriteBuf, store.workers)
    fl.writerDoneChan = make(chan struct{})
    fl.writerCurrentBuf = <-fl.writerFreeBufChan
    head := []byte("{{.TT}}STORE v0                   ")
    binary.BigEndian.PutUint32(head[28:], store.checksumInterval)
    fl.writerCurrentBuf.offset = uint32(copy(fl.writerCurrentBuf.buf, head))
    atomic.StoreUint32(&fl.writerOffset, fl.writerCurrentBuf.offset)
    go fl.writer()
    for i := 0; i < store.workers; i++ {
        go fl.writingChecksummer()
    }
    fl.readerFPs = make([]brimutil.ChecksummedReader, store.fileReaders)
    fl.readerLocks = make([]sync.Mutex, len(fl.readerFPs))
    fl.readerLens = make([][]byte, len(fl.readerFPs))
    for i := 0; i < len(fl.readerFPs); i++ {
        fp, err := openReadSeeker(fl.name)
        if err != nil {
            fl.writerFP.Close()
            for j := 0; j < i; j++ {
                fl.readerFPs[j].Close()
            }
            return nil, err
        }
        fl.readerFPs[i] = brimutil.NewChecksummedReader(fp, int(store.checksumInterval), murmur3.New32)
        fl.readerLens[i] = make([]byte, 4)
    }
    fl.id, err = store.addLocBlock(fl)
    if err != nil {
        return nil, err
    }
    return fl, nil
}

func (fl *{{.t}}StoreFile) timestampnano() int64 {
    return fl.nameTimestamp
}

func (fl *{{.t}}StoreFile) read(keyA uint64, keyB uint64{{if eq .t "group"}}, nameKeyA uint64, nameKeyB uint64{{end}}, timestampbits uint64, offset uint32, length uint32, value []byte) (uint64, []byte, error) {
    if timestampbits&_TSB_DELETION != 0 {
        return timestampbits, value, ErrNotFound
    }
    i := int(keyA>>1) % len(fl.readerFPs)
    fl.readerLocks[i].Lock()
    fl.readerFPs[i].Seek(int64(offset), 0)
    end := len(value) + int(length)
    if end <= cap(value) {
        value = value[:end]
    } else {
        value2 := make([]byte, end)
        copy(value2, value)
        value = value2
    }
    if _, err := io.ReadFull(fl.readerFPs[i], value[len(value)-int(length):]); err != nil {
        fl.readerLocks[i].Unlock()
        return timestampbits, value, err
    }
    fl.readerLocks[i].Unlock()
    return timestampbits, value, nil
}

func (fl *{{.t}}StoreFile) write(memBlock *{{.t}}MemBlock) {
    if memBlock == nil {
        return
    }
    memBlock.fileID = fl.id
    memBlock.fileOffset = atomic.LoadUint32(&fl.writerOffset)
    if len(memBlock.values) < 1 {
        fl.store.freeableMemBlockChans[fl.freeableMemBlockChanIndex] <- memBlock
        fl.freeableMemBlockChanIndex++
        if fl.freeableMemBlockChanIndex >= len(fl.store.freeableMemBlockChans) {
            fl.freeableMemBlockChanIndex = 0
        }
        return
    }
    left := len(memBlock.values)
    for left > 0 {
        n := copy(fl.writerCurrentBuf.buf[fl.writerCurrentBuf.offset:fl.store.checksumInterval], memBlock.values[len(memBlock.values)-left:])
        atomic.AddUint32(&fl.writerOffset, uint32(n))
        fl.writerCurrentBuf.offset += uint32(n)
        if fl.writerCurrentBuf.offset >= fl.store.checksumInterval {
            s := fl.writerCurrentBuf.seq
            fl.writerChecksumBufChan <- fl.writerCurrentBuf
            fl.writerCurrentBuf = <-fl.writerFreeBufChan
            fl.writerCurrentBuf.seq = s + 1
        }
        left -= n
    }
    if fl.writerCurrentBuf.offset == 0 {
        fl.store.freeableMemBlockChans[fl.freeableMemBlockChanIndex] <- memBlock
        fl.freeableMemBlockChanIndex++
        if fl.freeableMemBlockChanIndex >= len(fl.store.freeableMemBlockChans) {
            fl.freeableMemBlockChanIndex = 0
        }
    } else {
        fl.writerCurrentBuf.memBlocks = append(fl.writerCurrentBuf.memBlocks, memBlock)
    }
}

func (fl *{{.t}}StoreFile) closeWriting() error {
    if fl.writerChecksumBufChan == nil {
        return nil
    }
    var reterr error
    close(fl.writerChecksumBufChan)
    for i := 0; i < cap(fl.writerChecksumBufChan); i++ {
        <-fl.writerDoneChan
    }
    fl.writerToDiskBufChan <- nil
    <-fl.writerDoneChan
    term := []byte("TERM v0 ")
    left := len(term)
    for left > 0 {
        n := copy(fl.writerCurrentBuf.buf[fl.writerCurrentBuf.offset:fl.store.checksumInterval], term[len(term)-left:])
        left -= n
        fl.writerCurrentBuf.offset += uint32(n)
        if left > 0 {
            binary.BigEndian.PutUint32(fl.writerCurrentBuf.buf[fl.writerCurrentBuf.offset:], murmur3.Sum32(fl.writerCurrentBuf.buf[:fl.writerCurrentBuf.offset]))
            fl.writerCurrentBuf.offset += 4
        }
        if _, err := fl.writerFP.Write(fl.writerCurrentBuf.buf[:fl.writerCurrentBuf.offset]); err != nil {
            if reterr == nil {
                reterr = err
            }
            break
        }
        fl.writerCurrentBuf.offset = 0
    }
    if err := fl.writerFP.Close(); err != nil {
        if reterr == nil {
            reterr = err
        }
    }
    for _, memBlock := range fl.writerCurrentBuf.memBlocks {
        fl.store.freeableMemBlockChans[fl.freeableMemBlockChanIndex] <- memBlock
        fl.freeableMemBlockChanIndex++
        if fl.freeableMemBlockChanIndex >= len(fl.store.freeableMemBlockChans) {
            fl.freeableMemBlockChanIndex = 0
        }
    }
    fl.writerFP = nil
    fl.writerFreeBufChan = nil
    fl.writerChecksumBufChan = nil
    fl.writerToDiskBufChan = nil
    fl.writerDoneChan = nil
    fl.writerCurrentBuf = nil
    return reterr
}

func (fl *{{.t}}StoreFile) close() error {
    reterr := fl.closeWriting()
    for i, fp := range fl.readerFPs {
        // This will let any ongoing reads complete.
        fl.readerLocks[i].Lock()
        if err := fp.Close(); err != nil {
            if reterr == nil {
                reterr = err
            }
        }
        // This will release any pending reads, which will get errors
        // immediately. Essentially, there is a race between compaction
        // accomplishing its goal of rewriting all entries of a file to a new
        // file, and readers of those entries beginning to use the new entry
        // locations. It's a small window and the resulting errors should be
        // fairly few and easily recoverable on a re-read.
        fl.readerLocks[i].Unlock()
    }
    return reterr
}

func (fl *{{.t}}StoreFile) writingChecksummer() {
    for {
        buf := <-fl.writerChecksumBufChan
        if buf == nil {
            break
        }
        binary.BigEndian.PutUint32(buf.buf[fl.store.checksumInterval:], murmur3.Sum32(buf.buf[:fl.store.checksumInterval]))
        fl.writerToDiskBufChan <- buf
    }
    fl.writerDoneChan <- struct{}{}
}

func (fl *{{.t}}StoreFile) writer() {
    var seq int
    lastWasNil := false
    for {
        buf := <-fl.writerToDiskBufChan
        if buf == nil {
            if lastWasNil {
                break
            }
            lastWasNil = true
            fl.writerToDiskBufChan <- nil
            continue
        }
        lastWasNil = false
        if buf.seq != seq {
            fl.writerToDiskBufChan <- buf
            continue
        }
        if _, err := fl.writerFP.Write(buf.buf); err != nil {
            fl.store.logCritical("%s %s\n", fl.name, err)
            break
        }
        if len(buf.memBlocks) > 0 {
            for _, memBlock := range buf.memBlocks {
                fl.store.freeableMemBlockChans[fl.freeableMemBlockChanIndex] <- memBlock
                fl.freeableMemBlockChanIndex++
                if fl.freeableMemBlockChanIndex >= len(fl.store.freeableMemBlockChans) {
                    fl.freeableMemBlockChanIndex = 0
                }
            }
            buf.memBlocks = buf.memBlocks[:0]
        }
        buf.offset = 0
        fl.writerFreeBufChan <- buf
        seq++
    }
    fl.writerDoneChan <- struct{}{}
}
